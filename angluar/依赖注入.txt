控制反转
重要的面向对象编程的法则：消减计算机程序的耦合问题。
控制反转(Inverse of Control)：
依赖注入 dependency injection DI
依赖查找 dependency lookup 

哪些方面的控制被反转了?
依赖对象的获得被反转了.

许多非凡的应用都是由两个或是更多的类通过彼此的合作来实现业务逻辑，这使得每个对象都需要，与其它合作的对象(也就是所依赖的对象)的引用.如果这个活动过程要靠自身实现。那么这将导致代码高度耦合并且难以测试。

依赖倒置原理
倒置注入

应用控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象了。所以，控制反转是，关于一个对象如何获取它所以依赖的对象的引用。（不仅仅是对象，函数也可以）


classA {
	Ainterface a;
	A(){}
	AMethoed(){
		a = new AInterfaeImp();
	}

}


通过一个容器在需要的时候把这个依赖关系形成，即把需要的接口实现注入到需要它的类中。



工厂和对象生成这两者独立分割开来，目的就是提高灵活性和可维护性。

反射：根据给出的类名(字符串)来生成对象。

这种编程方式可以让对象在生成时才决定要生成哪一种对象。


对象生成因为是使用反射编程，在效率上有些损耗。


基于接口： 可服务的对象需要实现一个专门的接口，该接口提供了一个对象，可以重用这个对象查找依赖(其它服务).

基于setter： 通过JavaBean的属性(setter方法)为可服务对象指定服务。

基于构造函数: 通过构造函数的参数为可服务对象指定服务。


依赖注入：组件不做定位查询，只提供普通的Java方法让容器去决定依赖关系。容器全权负责的组件的装配，它会把符合依赖关系的对象通过构造函数传递给需要的对象. 通过JavaBean属性依赖关系的做法称为设置方法注入(setter injection) 依赖关系作为构造函数参数传入的做法称为构造器注入(Constructor Injection)

依赖注入背后一个核心思想，单一功能原则。





argument = 0

argument[0];

for ( var i=0; i<argument.lenght; i++ ) {
	$scope = argument[0] || [];
}

if ( $scope ) {
	
	return new function ( $scope ) {};
	
}

function argChange () {
	
	if ( argument === 0 ) {
		argument = [];
	} else {
		argument = argument;
	}

	return arugment;

}

