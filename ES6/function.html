<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		
		<script src="lib/traceur.js" type="text/javascript" charset="utf-8"></script>
		<script src="lib/traceur-bootstrap.js" type="text/javascript" charset="utf-8"></script>
		
		<script type="text/javascript">
			
//			'use strict';
			
//				function log ( x, y ) {
//					
//					if ( typeof y === undefined ) {
//						
//						y = y || 'world';
//						
//					}
//					
//					console.log(x, y);
//					
//				}
//				
//				log('Hello'); // Hello world
//				log('Hello', 'hi'); // Hello hi
//				log('Hello', ''); //   
//			

//					function Point ( x, y=10 ) {
//						this.x = x;
//						this.y = y;
//					}
//					
//					let p = new Point(100);
//					console.log(p);  // Point {x: 100, y: 10}

					
//					function fn ( x = 1, y ) {
//						
//						return [x ,y];
//						
//					}
//					
//					console.log( fn() );  // [1, undefined]
//					console.log( fn(2) );  // [2, undefined]
//					console.log( fn(undefined, 1) ); // [1, 1]
//					console.log( fn(null, 1) ); // [null, 1]
//					console.log( fn( , 10) ); // error 

						
//						function fn2 ( x, y = 1, z ) {
//							
//							return [x, y, z];
//							
//						}
//						
//						console.log( fn2() ); // [undefined, 1, undefined]
//						console.log( fn2(2) ); // [2, 1, undefiend]
//						console.log( fn2(2, undefined, 3) ); // [2, 1, 3]
//						console.log( fn2(2, , 3) ); // error 


//							let len1 = (function (a) {}).length;
//							
//							let len2 = (function (a = 5) {}).length; 
//							
//							let len3 = (function ( a, b, c = 1 ) {}).length;  
//							
//							console.log(len1); // 1
//							console.log(len2); // 0
//							console.log( len3 ); // 2


//								var x = 1;
//								
//								function fn ( x, y = x ) {
//									console.log(y);
//								}
//								
//								fn(2); // 2


//								let foo = 'outer';
//								
//								function bar ( func = x => foo ) {
//									
//									let foo = 'inner';
//									
//									console.log( func() ); // outer
//									
//								}
//								
//								bar();
//								// 函数bar的参数func的默认值是一个匿名函数，返回值为变量foo。这个匿名函数声明时，bar函数的作用域还没有形成，所以匿名函数里面的foo指向外层作用域foo

	
//					var x = 1;
//					function foo ( x, y = function () { x = 2; } ) {
//						
//						var x = 3;
//						
//						y();
//						
//						console.log(x);
//						
//					}
//					
//					foo(); // 3
//					
//					console.log(x);
//




//						function throwMsg () {
//							throw new Error('error');
//						}
//
//						function foo ( pro1 = throwMsg()  ) {
//							
//							return pro1;
//							
//						}
//						
//						foo(); // 抛出错误
//
//						function foo ( options = undefined ) {
//							
//						}
						
						
//						function add ( ...nums ) {
//							
//							let sum = 0;
//							
//							for ( let val of nums ) {
//								
//								sum += val;
//								
//							}
//							
//							return sum;
//							
//						}
//						
//						console.log( add(1, 2, 3) );

//							console.log(...[1, 2, 3]);
//							// 1 2 3
//							
//							console.log(1, ...[2, 3, 4], 5 );
//							// 1 2 3 4 5 

//								function add ( x, y ) {
//									
//									return x + y;
//									
//								}
//								
//								let nums = [10, 20];
//								
//								console.log( add(...nums) ); // 30
//							

//		function fn ( x, y, z, n, m, ...nums ) {
//			
//			console.log(...nums); // 5 ,6
//			
//		}
//		
//		let args = [1, 2];
//		
//		fn(-1, ...args, 3, ...[4, 5], 6);
//		


//			let moreArr = [3,4];
//			
//			let arr1 = [1, 2].concat(moreArr);
//			
//			console.log(arr1);
//			
//			console.log( [1, 2, ...moreArr] );
//			
//			
//			let arr2 = ['a', 'b'];
//			
//			let arr3 = ['c', 'd'];
//			
//			let arr4 = ['e', 'f'];
//			
//			// ES5的写法
//			console.log( arr2.concat(arr3, arr4) );
//			
//			// ES6的写法
//			console.log( [...arr2, ...arr3, ...arr4] );



//				const [first, ...rest] = [1, 2, 3, 4, 5];
//				
//				console.log( first, ...rest );
				
//				const [...butLast, last] = [1, 2, 3, 4, 5]; // SyntaxError: Rest element must be last element in array
//				
//				const [first, ...middle, last] = [1, 2, 3, 4, 5];  // SyntaxError: Rest element must be last element in array
			
			
			
//			console.log( [...'hello'] ); // ["h", "e", "l", "l", "o"]

//				let arrList = {
//					'0': 'a',
//					'1': 'b',
//					'2': 'c',
//					length: 3
//				}
//			
//					
//				console.log( [...Array.from(arrList)] ); // ["a", "b", "c"]  
//				console.log( [...arrList] );  // TypeError: arrList[Symbol.iterator] is not a function
//


//				let fn1 = function () {};
//				
//				// ES5
//				console.log( fn1.name ); // ''
//				
//				// ES6
//				console.log( fn1.name ); // fn1
//				
//				
//				const fn = function fn2 () {}
//				
//				// ES5
//				console.log( fn.name );  // fn2
//				
//				// ES6
//				console.log( fn.name ); // fn2
//				
//				// Function 构造函数
//				console.log( (new Function).name ); // 'anonymouse';
				
						
//				var fn = () => 5;
//				
//				// 等同于
//				var fn = function () { return 5; }
//				
//				
//				
//				var sum = (num1, num2) => num1 + num2;
//				
//				// 等同于
//				var sum = function ( num1, num2 ) { return num1 + num2 }

//					var getTemp = id => ({ id: id, name: 'cyan' });
				

//			let fn = (...s) => {
//				console.log(arguments);
//				console.log(this);
//				console.log(...s);
//			}
//			
//			const full = ( first, last ) => {
//				return first+ ' ' + last;
//			}
//			
//			// 等同于
//			function full( first, last ) {
//				return first+ ' ' + last;
//			}
				
				// 正常写法
//				[1, 2, 3].map(function ( x ) {
//						
//						return x * x;
//					
//				});
//			
//				// 箭头函数写法
//				[1, 2, 3].map( x => x * x );
//					

//			fn(10);

//				var f = () => {}
				
//				console.log( new f() );


//				function foo () {
//					
//					setTimeout(() => {
//						console.log( 'id:', this.id );  // 42
//					},100);
//
//					setTimeout(function () {
//						console.log('id: ' ,this.id); //41
//					}, 1000);
//						
//				}
//			
//				var id = 21;
//				
//				foo.call({ id: 42 });
//				// 箭头函数导致this总是只想函数定义生效时所在的对象

//				// ES6
//				function foo () {
//					
//					let _this = this;
//					
//					setTimeout( () => {
//						
//						console.log('id:', this.id);
//						
//					}, 100 );
//					
//				}
//				
//				foo();
//				
//				//ES5
//				function fn2 () {
//					let _this = this;
//					
//					setTimeout(function () {
//						console.log('id:', _this.id);
//					}, 100);
//				}
//				
//				fn2();
//				
//				// fn2中清楚的说明了，箭头函数里面根本没有自己的this，而是引用外层的this。 
				
				
//				function foo() {
//					
//				  return () => {
//				  	
//				  	console.log(this); // Object {id: 1}
//				  	
//				    return () => {
//				    	
//				    	console.log(this); // Object {id: 1}
//				    	
//				      return () => {
//				      	
//				      	console.log(this); // Object {id: 1}
//				      	
//				        console.log('id:', this.id); // id: 1
//				
//				      };
//				
//				    };
//				
//				  };
//				
//				}
//				
//				var f = foo.call( {id: 1} );
//				
//				f()()();   


//				function foo () {
//					
//					console.log('args:', arguments); // args: [1, 2, 3, 4]
//					
//					setTimeout( () => {
//						
//						console.log('args:', arguments); // args: [1, 2, 3, 4]
//						
//					},100 );
//					
//				}
//				
//				foo(...[1, 2, 3, 4]);
//			

//let insert = (value) => ({into: (array) => ({after: (afterValue) => {
//array.splice(array.indexOf(afterValue) + 1, 0, value);
//return array;
//}})});

//				let insert = (value) => ({
//					
//					into: (array) => ({
//						
//						after: (afterValue) => {
//							
//							array.splice( array.indexOf(afterValue) + 1, 0, value );
//							
//							return array;
//							
//						}
//						
//					})
//				});
//				
//				console.log( insert(2).into([1, 3]).after(1) ); //[1, 2, 3]


//					function fn (x) {
//						return g(x); // 函数的最后一步调用函数 g() ,就是指的尾调用
//					}
//				
//					// 不属于为调用的情形
//					function f1 ( x ) {
//						let y = g(x);
//						return y;	
//					}
//					// 调用函数  g(x) 之后，还有赋值操作。
//				
//					function f2 (x) {
//						return g(x) + 1; 
//					}
//					// 调用之后还有其它操作
//					
//					function f3 ( x ) {
//						g(x);
//					}
//					// f3 最后是返回 undefined
//					
//					
//					// 尾调用不一定要出现在函数的尾部
//					
//					function f ( x ) {
//						
//						if ( x > 0 ) {
//							return m(x);
//						}
//						
//						return n(x);
//						
//					}


//					function fn () {
//						let m = 1;
//						let n = 2;
//						return g(m+n); // 执行到这一步，完全可以删除fn()的调用帧，只保留 g(3)  的调用帧
//					}
//					
//					fn();
//					
//					// 等同于
//					function fn () {
//						return g(3);
//					}
//					
//					fn();
//					
//					// 等同于
//					g(3);
//					
//					// “尾调用优化”: 只保留内层函数的调用帧。

				
				
//					// 对比阶乘  使用尾递归 和 不使用尾递归的情形
//					
//					function factorial ( n ) {
//						
//						if ( n === 1 ) {
//							return 1;
//						}
//						
//						return n * factorial(n-1); 
//						
//					}
//					
//					
//					// 尾递归
//					function factorial2 ( n, total ) {
//						
//						if ( n === 1 ) {
//							return total;
//						}
//						
//						return factorial2( n-1, n * total );
//						
//					}
//					
//					factorial2( 5, 1 ); // 120


						function factorial ( n, total = 1 ) {
							
							if ( n === 1 ) return total;
							
							return factorial(n-1, n * total);
							
						}
						
						console.log( factorial(5) ); // 120;
					
		</script>
		
	</body>
</html>
